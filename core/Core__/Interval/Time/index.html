<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.2.0" />
<title>Time (core.Core__.Interval.Time)</title>
<link rel="stylesheet" href="../../../../odoc.css" />
<meta charset="utf-8" />
<meta name="viewport" content=
"width=device-width,initial-scale=1.0" />
<script src="../../../../highlight.pack.js">
</script>
<script>
<![CDATA[
hljs.initHighlightingOnLoad();
]]>
</script>
</head>
<body>
<div class="content">
<header>
<nav><a href="../index.html">Up</a> – <a href=
"../../../index.html">core</a> » <a href=
"../../index.html">Core__</a> » <a href=
"../index.html">Interval</a> » Time</nav>
<h1>Module <code>Interval.Time</code></h1>
</header>
<div>
<div class="spec include">
<div class="doc">
<details open="open">
<summary><span class="def"><code><span class=
"keyword">include</span> <a href=
"../../../Core/Interval_intf/index.html#module-type-S">Core.Interval_intf.S</a>
<span class="keyword">with</span> <span class="keyword">type</span>
<a href=
"../../../Core/Interval_intf/module-type-S/index.html#type-bound">bound</a>
= <a href=
"../../Import/Time/index.html#type-t">Core__.Import.Time.t</a></code></span></summary>
<dl>
<dt class="spec type" id="type-t"><a href="#type-t" class=
"anchor"></a><code><span class="keyword">type</span> t</code></dt>
</dl>
<div>
<div class="spec include">
<div class="doc">
<details open="open">
<summary><span class="def"><code><span class=
"keyword">include</span> <span class="keyword">sig</span> ...
<span class="keyword">end</span></code></span></summary>
<dl>
<dt class="spec value" id="val-bin_t"><a href="#val-bin_t" class=
"anchor"></a><code><span class="keyword">val</span> bin_t :
<a href="index.html#type-t">t</a> <a href=
"../../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></code></dt>
<dt class="spec value" id="val-bin_read_t"><a href=
"#val-bin_read_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_read_t : <a href="index.html#type-t">t</a>
<a href=
"../../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt>
<dt class="spec value" id="val-__bin_read_t__"><a href=
"#val-__bin_read_t__" class="anchor"></a><code><span class=
"keyword">val</span> __bin_read_t__ : (int <span>-&gt;</span>
<a href="index.html#type-t">t</a>) <a href=
"../../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></code></dt>
<dt class="spec value" id="val-bin_reader_t"><a href=
"#val-bin_reader_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_reader_t : <a href=
"index.html#type-t">t</a> <a href=
"../../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></code></dt>
<dt class="spec value" id="val-bin_size_t"><a href=
"#val-bin_size_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_size_t : <a href="index.html#type-t">t</a>
<a href=
"../../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></code></dt>
<dt class="spec value" id="val-bin_write_t"><a href=
"#val-bin_write_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_write_t : <a href=
"index.html#type-t">t</a> <a href=
"../../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></code></dt>
<dt class="spec value" id="val-bin_writer_t"><a href=
"#val-bin_writer_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_writer_t : <a href=
"index.html#type-t">t</a> <a href=
"../../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></code></dt>
<dt class="spec value" id="val-bin_shape_t"><a href=
"#val-bin_shape_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_shape_t : <a href=
"../../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></code></dt>
<dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp"
class="anchor"></a><code><span class="keyword">val</span> t_of_sexp
: <a href=
"../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>
<span>-&gt;</span> <a href="index.html#type-t">t</a></code></dt>
<dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t"
class="anchor"></a><code><span class="keyword">val</span> sexp_of_t
: <a href="index.html#type-t">t</a> <span>-&gt;</span> <a href=
"../../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt>
<dt class="spec value" id="val-compare"><a href="#val-compare"
class="anchor"></a><code><span class="keyword">val</span> compare :
<a href="index.html#type-t">t</a> <span>-&gt;</span> <a href=
"index.html#type-t">t</a> <span>-&gt;</span> int</code></dt>
<dt class="spec value" id="val-hash_fold_t"><a href=
"#val-hash_fold_t" class="anchor"></a><code><span class=
"keyword">val</span> hash_fold_t : <a href=
"../../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a>
<span>-&gt;</span> <a href="index.html#type-t">t</a>
<span>-&gt;</span> <a href=
"../../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a></code></dt>
<dt class="spec value" id="val-hash"><a href="#val-hash" class=
"anchor"></a><code><span class="keyword">val</span> hash : <a href=
"index.html#type-t">t</a> <span>-&gt;</span> <a href=
"../../../../base/Base/Hash/index.html#type-hash_value">Base.Hash.hash_value</a></code></dt>
</dl>
</details>
</div>
</div>
</div>
<dl>
<dt class="spec type" id="type-bound"><a href="#type-bound" class=
"anchor"></a><code><span class="keyword">type</span> bound</code>
<code>= <a href=
"../../Import/Time/index.html#type-t">Core__.Import.Time.t</a></code></dt>
<dt class="spec type" id="type-t_"><a href="#type-t_" class=
"anchor"></a><code><span class="keyword">type</span> 'a t_</code>
<code>= <a href="index.html#type-t">t</a></code></dt>
<dt class="spec type" id="type-bound_"><a href="#type-bound_"
class="anchor"></a><code><span class="keyword">type</span> 'a
bound_</code> <code>= <a href=
"index.html#type-bound">bound</a></code></dt>
</dl>
<div>
<div class="spec include">
<div class="doc">
<dl>
<dt class="spec value" id="val-create"><a href="#val-create" class=
"anchor"></a><code><span class="keyword">val</span> create :
<span class="type-var">'a</span> <a href=
"index.html#type-bound_">bound_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href="index.html#type-bound_">bound_</a>
<span>-&gt;</span> <span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a></code></dt>
<dd>
<p><code>create l u</code> returns the interval with lower bound
<code>l</code> and upper bound <code>u</code>, unless <code>l &gt;
u</code>, in which case it returns the empty interval.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-empty"><a href="#val-empty" class=
"anchor"></a><code><span class="keyword">val</span> empty :
<span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a></code></dt>
<dt class="spec value" id="val-intersect"><a href="#val-intersect"
class="anchor"></a><code><span class="keyword">val</span> intersect
: <span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href="index.html#type-t_">t_</a>
<span>-&gt;</span> <span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a></code></dt>
<dt class="spec value" id="val-is_empty"><a href="#val-is_empty"
class="anchor"></a><code><span class="keyword">val</span> is_empty
: <span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> bool</code></dt>
<dt class="spec value" id="val-is_empty_or_singleton"><a href=
"#val-is_empty_or_singleton" class="anchor"></a><code><span class=
"keyword">val</span> is_empty_or_singleton : <span class=
"type-var">'a</span> <a href="index.html#type-t_">t_</a>
<span>-&gt;</span> bool</code></dt>
<dt class="spec value" id="val-bounds"><a href="#val-bounds" class=
"anchor"></a><code><span class="keyword">val</span> bounds :
<span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> (<span class=
"type-var">'a</span> <a href="index.html#type-bound_">bound_</a> *
<span class="type-var">'a</span> <a href=
"index.html#type-bound_">bound_</a>) option</code></dt>
<dt class="spec value" id="val-lbound"><a href="#val-lbound" class=
"anchor"></a><code><span class="keyword">val</span> lbound :
<span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href="index.html#type-bound_">bound_</a>
option</code></dt>
<dt class="spec value" id="val-ubound"><a href="#val-ubound" class=
"anchor"></a><code><span class="keyword">val</span> ubound :
<span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href="index.html#type-bound_">bound_</a>
option</code></dt>
<dt class="spec value" id="val-bounds_exn"><a href=
"#val-bounds_exn" class="anchor"></a><code><span class=
"keyword">val</span> bounds_exn : <span class="type-var">'a</span>
<a href="index.html#type-t_">t_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href="index.html#type-bound_">bound_</a> *
<span class="type-var">'a</span> <a href=
"index.html#type-bound_">bound_</a></code></dt>
<dt class="spec value" id="val-lbound_exn"><a href=
"#val-lbound_exn" class="anchor"></a><code><span class=
"keyword">val</span> lbound_exn : <span class="type-var">'a</span>
<a href="index.html#type-t_">t_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href=
"index.html#type-bound_">bound_</a></code></dt>
<dt class="spec value" id="val-ubound_exn"><a href=
"#val-ubound_exn" class="anchor"></a><code><span class=
"keyword">val</span> ubound_exn : <span class="type-var">'a</span>
<a href="index.html#type-t_">t_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href=
"index.html#type-bound_">bound_</a></code></dt>
<dt class="spec value" id="val-convex_hull"><a href=
"#val-convex_hull" class="anchor"></a><code><span class=
"keyword">val</span> convex_hull : <span class="type-var">'a</span>
<a href="index.html#type-t_">t_</a> list <span>-&gt;</span>
<span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a></code></dt>
<dd>
<p><code>convex_hull ts</code> returns an interval whose upper
bound is the greatest upper bound of the intervals in the list, and
whose lower bound is the least lower bound of the list.</p>
<p>Suppose you had three intervals <code>a</code>, <code>b</code>,
and <code>c</code>:</p>
<pre>             a:  (   )
             b:    (     )
             c:            ( )

          hull:  (           )</pre>
<p>In this case the hull goes from <code>lbound_exn a</code> to
<code>ubound_exn c</code>.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-contains"><a href="#val-contains"
class="anchor"></a><code><span class="keyword">val</span> contains
: <span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href="index.html#type-bound_">bound_</a>
<span>-&gt;</span> bool</code></dt>
<dt class="spec value" id="val-compare_value"><a href=
"#val-compare_value" class="anchor"></a><code><span class=
"keyword">val</span> compare_value : <span class=
"type-var">'a</span> <a href="index.html#type-t_">t_</a>
<span>-&gt;</span> <span class="type-var">'a</span> <a href=
"index.html#type-bound_">bound_</a> <span>-&gt;</span> [ `Below |
`Within | `Above | `Interval_is_empty ]</code></dt>
<dt class="spec value" id="val-bound"><a href="#val-bound" class=
"anchor"></a><code><span class="keyword">val</span> bound :
<span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> <span class=
"type-var">'a</span> <a href="index.html#type-bound_">bound_</a>
<span>-&gt;</span> <span class="type-var">'a</span> <a href=
"index.html#type-bound_">bound_</a> option</code></dt>
<dd>
<p><code>bound t x</code> returns <code>None</code> iff
<code>is_empty t</code>. If <code>bounds t = Some (a, b)</code>,
then <code>bound</code> returns <code>Some y</code> where
<code>y</code> is the element of <code>t</code> closest to
<code>x</code>. I.e.:</p>
<pre>        y = a  if x &lt; a
        y = x  if a &lt;= x &lt;= b
        y = b  if x &gt; b</pre></dd>
</dl>
<dl>
<dt class="spec value" id="val-is_superset"><a href=
"#val-is_superset" class="anchor"></a><code><span class=
"keyword">val</span> is_superset : <span class="type-var">'a</span>
<a href="index.html#type-t_">t_</a> <span>-&gt;</span>
of_:<span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> bool</code></dt>
<dd>
<p><code>is_superset i1 of_:i2</code> is whether i1 contains i2.
The empty interval is contained in every interval.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-is_subset"><a href="#val-is_subset"
class="anchor"></a><code><span class="keyword">val</span> is_subset
: <span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> of_:<span class=
"type-var">'a</span> <a href="index.html#type-t_">t_</a>
<span>-&gt;</span> bool</code></dt>
<dt class="spec value" id="val-map"><a href="#val-map" class=
"anchor"></a><code><span class="keyword">val</span> map :
<span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> <span>-&gt;</span> f:(<span class=
"type-var">'a</span> <a href="index.html#type-bound_">bound_</a>
<span>-&gt;</span> <span class="type-var">'b</span> <a href=
"index.html#type-bound_">bound_</a>) <span>-&gt;</span>
<span class="type-var">'b</span> <a href=
"index.html#type-t_">t_</a></code></dt>
<dd>
<p><code>map t ~f</code> returns <code>create (f l) (f u)</code> if
<code>bounds t = Some (l, u)</code>, and <code>empty</code> if
<code>t</code> is empty. Note that if <code>f l &gt; f u</code>,
the result of <code>map</code> is <code>empty</code>, by the
definition of <code>create</code>.</p>
<p>If you think of an interval as a set of points, rather than a
pair of its bounds, then <code>map</code> is not the same as the
usual mathematical notion of mapping <code>f</code> over that set.
For example, <code>map ~f:(fun x -&gt; x * x)</code> maps the
interval <code>[-1,1]</code> to <code>[1,1]</code>, not to
<code>[0,1]</code>.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-are_disjoint"><a href=
"#val-are_disjoint" class="anchor"></a><code><span class=
"keyword">val</span> are_disjoint : <span class=
"type-var">'a</span> <a href="index.html#type-t_">t_</a> list
<span>-&gt;</span> bool</code></dt>
<dd>
<p><code>are_disjoint ts</code> returns <code>true</code> iff the
intervals in <code>ts</code> are pairwise disjoint.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-are_disjoint_as_open_intervals">
<a href="#val-are_disjoint_as_open_intervals" class=
"anchor"></a><code><span class="keyword">val</span>
are_disjoint_as_open_intervals : <span class="type-var">'a</span>
<a href="index.html#type-t_">t_</a> list <span>-&gt;</span>
bool</code></dt>
<dd>
<p>Returns true iff a given set of intervals would be disjoint if
considered as open intervals, e.g., <code>(3,4)</code> and
<code>(4,5)</code> would count as disjoint according to this
function.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-list_intersect"><a href=
"#val-list_intersect" class="anchor"></a><code><span class=
"keyword">val</span> list_intersect : <span class=
"type-var">'a</span> <a href="index.html#type-t_">t_</a> list
<span>-&gt;</span> <span class="type-var">'a</span> <a href=
"index.html#type-t_">t_</a> list <span>-&gt;</span> <span class=
"type-var">'a</span> <a href="index.html#type-t_">t_</a>
list</code></dt>
<dd>
<p>Assuming that <code>ilist1</code> and <code>ilist2</code> are
lists of disjoint intervals, <code>list_intersect ilist1
ilist2</code> considers the intersection <code>(intersect i1
i2)</code> of every pair of intervals <code>(i1, i2)</code>, with
<code>i1</code> drawn from <code>ilist1</code> and <code>i2</code>
from <code>ilist2</code>, returning just the non-empty
intersections. By construction these intervals will be disjoint,
too. For example:</p>
<pre><code class="ml">let i = Interval.create;;
list_intersect [i 4 7; i 9 15] [i 2 4; i 5 10; i 14 20];;
[(4, 4), (5, 7), (9, 10), (14, 15)]</code></pre>
<p>Raises an exception if either input list is non-disjoint.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id=
"val-half_open_intervals_are_a_partition"><a href=
"#val-half_open_intervals_are_a_partition" class=
"anchor"></a><code><span class="keyword">val</span>
half_open_intervals_are_a_partition : <span class=
"type-var">'a</span> <a href="index.html#type-t_">t_</a> list
<span>-&gt;</span> bool</code></dt>
<dd>
<p>Returns true if the intervals, when considered as half-open
intervals, nestle up cleanly one to the next. I.e., if you sort the
intervals by the lower bound, then the upper bound of the
<code>n</code>th interval is equal to the lower bound of the
<code>n+1</code>th interval. The intervals do not need to partition
the entire space, they just need to partition their union.</p>
</dd>
</dl>
</div>
</div>
</div>
<dl>
<dt class="spec value" id="val-create"><a href="#val-create" class=
"anchor"></a><code><span class="keyword">val</span> create :
<a href="index.html#type-bound">bound</a> <span>-&gt;</span>
<a href="index.html#type-bound">bound</a> <span>-&gt;</span>
<a href="index.html#type-t">t</a></code></dt>
<dd>
<p><code>create</code> has the same type as in <code>Gen</code>,
but adding it here prevents a type-checker issue with
nongeneralizable type variables.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-to_poly"><a href="#val-to_poly"
class="anchor"></a><code><span class="keyword">val</span> to_poly :
<a href="index.html#type-t">t</a> <span>-&gt;</span> <a href=
"index.html#type-bound">bound</a> <a href=
"../index.html#type-t">t</a></code></dt>
</dl>
<div class="spec module" id="module-Set"><a href="#module-Set"
class="anchor"></a><code><span class="keyword">module</span>
<a href="Set/index.html">Set</a> : <span class="keyword">sig</span>
... <span class="keyword">end</span> <span class=
"keyword">with</span> <span class="keyword">type</span> 'a <a href=
"Set/index.html#type-interval">interval</a> := <span class=
"type-var">'a</span> <a href=
"index.html#type-t_">t_</a></code></div>
</details>
</div>
</div>
</div>
<dl>
<dt class="spec value" id="val-create_ending_after"><a href=
"#val-create_ending_after" class="anchor"></a><code><span class=
"keyword">val</span> create_ending_after : ?⁠zone:<a href=
"../../../Core__Core_time_float/Zone/index.html#type-t">Core.Interval_intf.Zone.t</a>
<span>-&gt;</span> (<a href=
"Time/Ofday/index.html#type-t">Time.Ofday.t</a> * <a href=
"Time/Ofday/index.html#type-t">Time.Ofday.t</a>) <span>-&gt;</span>
now:<a href=
"../../Import/Time/index.html#type-t">Core__.Import.Time.t</a>
<span>-&gt;</span> <a href="index.html#type-t">t</a></code></dt>
<dd>
<p><code>create_ending_after ?zone (od1, od2) ~now</code> returns
the smallest interval <code>(t1 t2)</code> with minimum
<code>t2</code> such that <code>t2 &gt;= now</code>, <code>to_ofday
t1 = od1</code>, and <code>to_ofday t2 = od2</code>. If a zone is
specified, it is used to translate <code>od1</code> and
<code>od2</code> into times, otherwise the machine's time zone is
used.</p>
<p>It is not guaranteed that the interval will contain
<code>now</code>: for instance if it's 11:15am, <code>od1</code> is
12pm, and <code>od2</code> is 2pm, the returned interval will be
12pm-2pm today, which obviously doesn't include 11:15am. In general
<code>contains (t1 t2) now</code> will only be true when now is
between <code>to_ofday od1</code> and <code>to_ofday
od2</code>.</p>
<p>You might want to use this function if, for example, there's a
daily meeting from 10:30am-11:30am and you want to find the next
instance of the meeting, relative to now.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-create_ending_before"><a href=
"#val-create_ending_before" class="anchor"></a><code><span class=
"keyword">val</span> create_ending_before : ?⁠zone:<a href=
"../../../Core__Core_time_float/Zone/index.html#type-t">Core.Interval_intf.Zone.t</a>
<span>-&gt;</span> (<a href=
"Time/Ofday/index.html#type-t">Time.Ofday.t</a> * <a href=
"Time/Ofday/index.html#type-t">Time.Ofday.t</a>) <span>-&gt;</span>
ubound:<a href=
"../../Import/Time/index.html#type-t">Core__.Import.Time.t</a>
<span>-&gt;</span> <a href="index.html#type-t">t</a></code></dt>
<dd>
<p><code>create_ending_before ?zone (od1, od2) ~ubound</code>
returns the smallest interval <code>(t1 t2)</code> with maximum
<code>t2</code> such that <code>t2 &lt;= ubound</code>,
<code>to_ofday t1 = od1</code>, and <code>to_ofday t2 = od2</code>.
If a zone is specified, it is used to translate <code>od1</code>
and <code>od2</code> into times, otherwise the machine's time zone
is used.</p>
<p>You might want to use this function if, for example, there's a
lunch hour from noon to 1pm and you want to find the first instance
of that lunch hour (an interval) before <code>ubound</code>. The
result will either be on the same day as <code>ubound</code>, if
<code>to_ofday ubound</code> is after 1pm, or the day before, if
<code>to_ofday ubound</code> is any earlier.</p>
</dd>
</dl>
</div>
</body>
</html>
