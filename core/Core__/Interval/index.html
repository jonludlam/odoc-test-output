<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0" />
<meta charset="utf-8" />
<title>Interval (core.Core__.Interval)</title>
<link rel="stylesheet" href="../../../odoc.css" />
<meta name="viewport" content=
"width=device-width,initial-scale=1.0" />
<script src="../../../highlight.pack.js"></script>
<script>
<![CDATA[
hljs.initHighlightingOnLoad();
]]>
</script>
</head>
<body>
<div class="content">
<header>
<nav><a href="../index.html">Up</a> – <a href=
"../../index.html">core</a> » <a href="../index.html">Core__</a> »
Interval</nav>
<h1>Module <code>Core__.Interval</code></h1>
<nav class="toc">
<ul>
<li><a href="#type-specialized-intervals">Type-specialized
intervals</a>
<ul>
<li><a href="#signatures">Signatures</a></li>
<li><a href="#specialized-interval-types">Specialized interval
types</a></li>
</ul>
</li>
</ul>
</nav>
</header>
<aside>
<p>Module for simple closed intervals over arbitrary types. Used by
calling the <a href=
"Make/index.html"><span><code>Make</code></span></a> functor with a
type that satisfies <a href=
"../../../base/Base/Comparable/index.html"><span><code>Comparable</code></span></a>
(for correctly ordering elements).</p>
<p>Note that the actual interface for intervals is in <a href=
"../../Core/Interval_intf/module-type-Gen/index.html"><span><code>Interval_intf.Gen</code></span></a>,
following a Core pattern of defining an interface once in a
<code>Gen</code> module, then reusing it across monomorphic
(<code>S</code>) and polymorphic (<code>S1</code>, <code>S2</code>,
... <code>SN</code>) variants, where <code>SN</code> denotes a
signature of N parameters. Here, <code>S1</code> is included in
this module because the signature of one <code>'a</code> parameter
is the default.</p>
<p>See the documentation of <a href=
"Make/index.html"><span><code>Interval.Make</code></span></a> for a
more detailed usage example.</p>
</aside>
<div>
<div class="spec include">
<div class="doc">
<h3 id="intervals-using-polymorphic-compare"><a href=
"#intervals-using-polymorphic-compare" class="anchor"></a>Intervals
using polymorphic compare</h3>
<p>This part of the interface is for polymorphic intervals, which
are well ordered by polymorphic compare. Using this with types that
are not (like sets) will lead to crazy results.</p>
<dl>
<dt class="spec type" id="type-t"><a href="#type-t" class=
"anchor"></a><code><span class="keyword">type</span> <span>'a
t</span></code></dt>
<dd>
<p>This type <code>t</code> supports bin-io and sexp conversion by
way of the <code>[@@deriving bin_io, sexp]</code> extensions, which
inline the relevant function signatures (like
<code>bin_read_t</code> and <code>t_of_sexp</code>).</p>
</dd>
</dl>
<div>
<div class="spec include">
<div class="doc">
<details open="open">
<summary><span class="def"><code><span class=
"keyword">include</span> <span class="keyword">sig</span> ...
<span class="keyword">end</span></code></span></summary>
<dl>
<dt class="spec value" id="val-bin_t"><a href="#val-bin_t" class=
"anchor"></a><code><span class="keyword">val</span> bin_t :
<span><span class="type-var">'a</span> <a href=
"../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></span>
<span>-&gt;</span> <span><span><span class="type-var">'a</span>
<a href="index.html#type-t">t</a></span> <a href=
"../../../bin_prot/Bin_prot/Type_class/index.html#type-t">Bin_prot.Type_class.t</a></span></code></dt>
<dt class="spec value" id="val-bin_read_t"><a href=
"#val-bin_read_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_read_t : <span><span class=
"type-var">'a</span> <a href=
"../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span>
<span>-&gt;</span> <span><span><span class="type-var">'a</span>
<a href="index.html#type-t">t</a></span> <a href=
"../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span></code></dt>
<dt class="spec value" id="val-__bin_read_t__"><a href=
"#val-__bin_read_t__" class="anchor"></a><code><span class=
"keyword">val</span> __bin_read_t__ : <span><span class=
"type-var">'a</span> <a href=
"../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span>
<span>-&gt;</span> <span><span>(int <span>-&gt;</span>
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span>)</span> <a href=
"../../../bin_prot/Bin_prot/Read/index.html#type-reader">Bin_prot.Read.reader</a></span></code></dt>
<dt class="spec value" id="val-bin_reader_t"><a href=
"#val-bin_reader_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_reader_t : <span><span class=
"type-var">'a</span> <a href=
"../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span>
<span>-&gt;</span> <span><span><span class="type-var">'a</span>
<a href="index.html#type-t">t</a></span> <a href=
"../../../bin_prot/Bin_prot/Type_class/index.html#type-reader">Bin_prot.Type_class.reader</a></span></code></dt>
<dt class="spec value" id="val-bin_size_t"><a href=
"#val-bin_size_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_size_t : <span><span class=
"type-var">'a</span> <a href=
"../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></span>
<span>-&gt;</span> <span><span><span class="type-var">'a</span>
<a href="index.html#type-t">t</a></span> <a href=
"../../../bin_prot/Bin_prot/Size/index.html#type-sizer">Bin_prot.Size.sizer</a></span></code></dt>
<dt class="spec value" id="val-bin_write_t"><a href=
"#val-bin_write_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_write_t : <span><span class=
"type-var">'a</span> <a href=
"../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></span>
<span>-&gt;</span> <span><span><span class="type-var">'a</span>
<a href="index.html#type-t">t</a></span> <a href=
"../../../bin_prot/Bin_prot/Write/index.html#type-writer">Bin_prot.Write.writer</a></span></code></dt>
<dt class="spec value" id="val-bin_writer_t"><a href=
"#val-bin_writer_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_writer_t : <span><span class=
"type-var">'a</span> <a href=
"../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></span>
<span>-&gt;</span> <span><span><span class="type-var">'a</span>
<a href="index.html#type-t">t</a></span> <a href=
"../../../bin_prot/Bin_prot/Type_class/index.html#type-writer">Bin_prot.Type_class.writer</a></span></code></dt>
<dt class="spec value" id="val-bin_shape_t"><a href=
"#val-bin_shape_t" class="anchor"></a><code><span class=
"keyword">val</span> bin_shape_t : <a href=
"../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a>
<span>-&gt;</span> <a href=
"../../../bin_prot/Bin_prot/Shape/index.html#type-t">Bin_prot.Shape.t</a></code></dt>
<dt class="spec value" id="val-t_of_sexp"><a href="#val-t_of_sexp"
class="anchor"></a><code><span class="keyword">val</span> t_of_sexp
: <span>(<a href=
"../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>
<span>-&gt;</span> <span class="type-var">'a</span>)</span>
<span>-&gt;</span> <a href=
"../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>
<span>-&gt;</span> <span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span></code></dt>
<dt class="spec value" id="val-sexp_of_t"><a href="#val-sexp_of_t"
class="anchor"></a><code><span class="keyword">val</span> sexp_of_t
: <span>(<span class="type-var">'a</span> <span>-&gt;</span>
<a href=
"../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a>)</span>
<span>-&gt;</span> <span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span> <a href=
"../../../sexplib0/Sexplib0/Sexp/index.html#type-t">Ppx_sexp_conv_lib.Sexp.t</a></code></dt>
<dt class="spec value" id="val-compare"><a href="#val-compare"
class="anchor"></a><code><span class="keyword">val</span> compare :
<span>(<span class="type-var">'a</span> <span>-&gt;</span>
<span class="type-var">'a</span> <span>-&gt;</span> int)</span>
<span>-&gt;</span> <span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span> int</code></dt>
<dt class="spec value" id="val-hash_fold_t"><a href=
"#val-hash_fold_t" class="anchor"></a><code><span class=
"keyword">val</span> hash_fold_t : <span>(<a href=
"../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a>
<span>-&gt;</span> <span class="type-var">'a</span>
<span>-&gt;</span> <a href=
"../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a>)</span>
<span>-&gt;</span> <a href=
"../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a>
<span>-&gt;</span> <span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span> <a href=
"../../../base/Base/Hash/index.html#type-state">Base.Hash.state</a></code></dt>
</dl>
</details>
</div>
</div>
</div>
<dl>
<dt class="spec type" id="type-bound_"><a href="#type-bound_"
class="anchor"></a><code><span class="keyword">type</span> <span>'a
bound_</span></code> <code>= <span class=
"type-var">'a</span></code></dt>
</dl>
<div>
<div class="spec include">
<div class="doc">
<dl>
<dt class="spec type" id="type-t"><a href="#type-t" class=
"anchor"></a><code><span class="keyword">type</span> <span>'a
t</span></code></dt>
<dt class="spec type" id="type-bound"><a href="#type-bound" class=
"anchor"></a><code><span class="keyword">type</span> <span>'a
bound</span></code></dt>
<dd>
<p><code>bound</code> is the type of points in the interval (and
therefore of the bounds). <code>bound</code> is instantiated in two
different ways below: in <code>module type S</code> as a monotype
and in <code>module type S1</code> as <code>'a</code>.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-create"><a href="#val-create" class=
"anchor"></a><code><span class="keyword">val</span> create :
<span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> <span>-&gt;</span>
<span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> <span>-&gt;</span>
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span></code></dt>
<dd>
<p><code>create l u</code> returns the interval with lower bound
<code>l</code> and upper bound <code>u</code>, unless <code>l &gt;
u</code>, in which case it returns the empty interval.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-empty"><a href="#val-empty" class=
"anchor"></a><code><span class="keyword">val</span> empty :
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span></code></dt>
<dt class="spec value" id="val-intersect"><a href="#val-intersect"
class="anchor"></a><code><span class="keyword">val</span> intersect
: <span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span></code></dt>
<dt class="spec value" id="val-is_empty"><a href="#val-is_empty"
class="anchor"></a><code><span class="keyword">val</span> is_empty
: <span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
bool</code></dt>
<dt class="spec value" id="val-is_empty_or_singleton"><a href=
"#val-is_empty_or_singleton" class="anchor"></a><code><span class=
"keyword">val</span> is_empty_or_singleton : <span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
<span>-&gt;</span> bool</code></dt>
<dt class="spec value" id="val-bounds"><a href="#val-bounds" class=
"anchor"></a><code><span class="keyword">val</span> bounds :
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span><span>(<span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> * <span><span class=
"type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span>)</span>
option</span></code></dt>
<dt class="spec value" id="val-lbound"><a href="#val-lbound" class=
"anchor"></a><code><span class="keyword">val</span> lbound :
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span><span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> option</span></code></dt>
<dt class="spec value" id="val-ubound"><a href="#val-ubound" class=
"anchor"></a><code><span class="keyword">val</span> ubound :
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span><span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> option</span></code></dt>
<dt class="spec value" id="val-bounds_exn"><a href=
"#val-bounds_exn" class="anchor"></a><code><span class=
"keyword">val</span> bounds_exn : <span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
<span>-&gt;</span> <span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> * <span><span class=
"type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span></code></dt>
<dt class="spec value" id="val-lbound_exn"><a href=
"#val-lbound_exn" class="anchor"></a><code><span class=
"keyword">val</span> lbound_exn : <span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
<span>-&gt;</span> <span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span></code></dt>
<dt class="spec value" id="val-ubound_exn"><a href=
"#val-ubound_exn" class="anchor"></a><code><span class=
"keyword">val</span> ubound_exn : <span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
<span>-&gt;</span> <span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span></code></dt>
<dt class="spec value" id="val-convex_hull"><a href=
"#val-convex_hull" class="anchor"></a><code><span class=
"keyword">val</span> convex_hull : <span><span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
list</span> <span>-&gt;</span> <span><span class=
"type-var">'a</span> <a href=
"index.html#type-t">t</a></span></code></dt>
<dd>
<p><code>convex_hull ts</code> returns an interval whose upper
bound is the greatest upper bound of the intervals in the list, and
whose lower bound is the least lower bound of the list.</p>
<p>Suppose you had three intervals <code>a</code>, <code>b</code>,
and <code>c</code>:</p>
<pre>             a:  (   )
             b:    (     )
             c:            ( )

          hull:  (           )</pre>
<p>In this case the hull goes from <code>lbound_exn a</code> to
<code>ubound_exn c</code>.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-contains"><a href="#val-contains"
class="anchor"></a><code><span class="keyword">val</span> contains
: <span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> <span>-&gt;</span>
bool</code></dt>
<dt class="spec value" id="val-compare_value"><a href=
"#val-compare_value" class="anchor"></a><code><span class=
"keyword">val</span> compare_value : <span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
<span>-&gt;</span> <span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> <span>-&gt;</span> <span>[
`Below <span>| `Within</span> <span>| `Above</span> <span>|
`Interval_is_empty</span> ]</span></code></dt>
<dt class="spec value" id="val-bound"><a href="#val-bound" class=
"anchor"></a><code><span class="keyword">val</span> bound :
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> <span>-&gt;</span>
<span><span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> option</span></code></dt>
<dd>
<p><code>bound t x</code> returns <code>None</code> iff
<code>is_empty t</code>. If <code>bounds t = Some (a, b)</code>,
then <code>bound</code> returns <code>Some y</code> where
<code>y</code> is the element of <code>t</code> closest to
<code>x</code>. I.e.:</p>
<pre>        y = a  if x &lt; a
        y = x  if a &lt;= x &lt;= b
        y = b  if x &gt; b</pre></dd>
</dl>
<dl>
<dt class="spec value" id="val-is_superset"><a href=
"#val-is_superset" class="anchor"></a><code><span class=
"keyword">val</span> is_superset : <span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
<span>-&gt;</span> <span>of_:<span><span class="type-var">'a</span>
<a href="index.html#type-t">t</a></span></span> <span>-&gt;</span>
bool</code></dt>
<dd>
<p><code>is_superset i1 of_:i2</code> is whether i1 contains i2.
The empty interval is contained in every interval.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-is_subset"><a href="#val-is_subset"
class="anchor"></a><code><span class="keyword">val</span> is_subset
: <span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span>of_:<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span></span> <span>-&gt;</span>
bool</code></dt>
<dt class="spec value" id="val-map"><a href="#val-map" class=
"anchor"></a><code><span class="keyword">val</span> map :
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span>-&gt;</span>
<span>f:<span>(<span><span class="type-var">'a</span> <a href=
"index.html#type-bound">bound</a></span> <span>-&gt;</span>
<span><span class="type-var">'b</span> <a href=
"index.html#type-bound">bound</a></span>)</span></span>
<span>-&gt;</span> <span><span class="type-var">'b</span> <a href=
"index.html#type-t">t</a></span></code></dt>
<dd>
<p><code>map t ~f</code> returns <code>create (f l) (f u)</code> if
<code>bounds t = Some (l, u)</code>, and <code>empty</code> if
<code>t</code> is empty. Note that if <code>f l &gt; f u</code>,
the result of <code>map</code> is <code>empty</code>, by the
definition of <code>create</code>.</p>
<p>If you think of an interval as a set of points, rather than a
pair of its bounds, then <code>map</code> is not the same as the
usual mathematical notion of mapping <code>f</code> over that set.
For example, <code>map ~f:(fun x -&gt; x * x)</code> maps the
interval <code>[-1,1]</code> to <code>[1,1]</code>, not to
<code>[0,1]</code>.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-are_disjoint"><a href=
"#val-are_disjoint" class="anchor"></a><code><span class=
"keyword">val</span> are_disjoint : <span><span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
list</span> <span>-&gt;</span> bool</code></dt>
<dd>
<p><code>are_disjoint ts</code> returns <code>true</code> iff the
intervals in <code>ts</code> are pairwise disjoint.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-are_disjoint_as_open_intervals">
<a href="#val-are_disjoint_as_open_intervals" class=
"anchor"></a><code><span class="keyword">val</span>
are_disjoint_as_open_intervals : <span><span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
list</span> <span>-&gt;</span> bool</code></dt>
<dd>
<p>Returns true iff a given set of intervals would be disjoint if
considered as open intervals, e.g., <code>(3,4)</code> and
<code>(4,5)</code> would count as disjoint according to this
function.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id="val-list_intersect"><a href=
"#val-list_intersect" class="anchor"></a><code><span class=
"keyword">val</span> list_intersect : <span><span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
list</span> <span>-&gt;</span> <span><span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
list</span> <span>-&gt;</span> <span><span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
list</span></code></dt>
<dd>
<p>Assuming that <code>ilist1</code> and <code>ilist2</code> are
lists of disjoint intervals, <code>list_intersect ilist1
ilist2</code> considers the intersection <code>(intersect i1
i2)</code> of every pair of intervals <code>(i1, i2)</code>, with
<code>i1</code> drawn from <code>ilist1</code> and <code>i2</code>
from <code>ilist2</code>, returning just the non-empty
intersections. By construction these intervals will be disjoint,
too. For example:</p>
<pre><code class="ml">let i = Interval.create;;
list_intersect [i 4 7; i 9 15] [i 2 4; i 5 10; i 14 20];;
[(4, 4), (5, 7), (9, 10), (14, 15)]</code></pre>
<p>Raises an exception if either input list is non-disjoint.</p>
</dd>
</dl>
<dl>
<dt class="spec value" id=
"val-half_open_intervals_are_a_partition"><a href=
"#val-half_open_intervals_are_a_partition" class=
"anchor"></a><code><span class="keyword">val</span>
half_open_intervals_are_a_partition : <span><span><span class=
"type-var">'a</span> <a href="index.html#type-t">t</a></span>
list</span> <span>-&gt;</span> bool</code></dt>
<dd>
<p>Returns true if the intervals, when considered as half-open
intervals, nestle up cleanly one to the next. I.e., if you sort the
intervals by the lower bound, then the upper bound of the
<code>n</code>th interval is equal to the lower bound of the
<code>n+1</code>th interval. The intervals do not need to partition
the entire space, they just need to partition their union.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="spec module" id="module-Set"><a href="#module-Set"
class="anchor"></a><code><span class="keyword">module</span>
<a href="Set/index.html">Set</a> : <span class="keyword">sig</span>
... <span class="keyword">end</span> <span class=
"keyword">with</span> <span class="keyword">type</span> <span>'a
<a href="Set/index.html#type-bound">bound</a></span> :=
<span><span class="type-var">'a</span> <a href=
"index.html#type-bound_">bound_</a></span> <span class=
"keyword">with</span> <span class="keyword">type</span> <span>'a
<a href="Set/index.html#type-interval">interval</a></span> :=
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span></code></div>
</div>
</div>
</div>
<section>
<header>
<h3 id="type-specialized-intervals"><a href=
"#type-specialized-intervals" class="anchor"></a>Type-specialized
intervals</h3>
<p>The module type <code>S</code> is used to define signatures for
intervals over a specific type, like <code>Interval.Ofday</code>
(whose bounds are <code>Time.Ofday.t</code>) or
<code>Interval.Float</code>, whose bounds are floats.</p>
<p>Note the heavy use of destructive substitution, which removes
the redefined type or module from the signature. This allows for
clean type constraints in codebases, like Core's, where there are
lots of types going by the same name (e.g., "t").</p>
</header>
<section>
<header>
<h4 id="signatures"><a href="#signatures" class=
"anchor"></a>Signatures</h4>
<p>The following signatures are used for specifying the types of
the type-specialized intervals.</p>
</header>
<div class="spec module-type" id="module-type-S1"><a href=
"#module-type-S1" class="anchor"></a><code><span class=
"keyword">module</span> <span class="keyword">type</span> <a href=
"module-type-S1/index.html">S1</a> = <a href=
"../../Core/Interval_intf/index.html#module-type-S1">Core.Interval_intf.S1</a></code></div>
<div class="spec module-type" id="module-type-S"><a href=
"#module-type-S" class="anchor"></a><code><span class=
"keyword">module</span> <span class="keyword">type</span> <a href=
"module-type-S/index.html">S</a> = <a href=
"../../Core/Interval_intf/index.html#module-type-S">Core.Interval_intf.S</a>
<span class="keyword">with</span> <span class="keyword">type</span>
<span>'a <a href=
"module-type-S/index.html#type-poly_t">poly_t</a></span> :=
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span class="keyword">with</span>
<span class="keyword">type</span> <span>'a <a href=
"module-type-S/index.html#type-poly_set">poly_set</a></span> :=
<span><span class="type-var">'a</span> <a href=
"Set/index.html#type-t">Set.t</a></span></code></div>
<dl>
<dt class="spec module-type" id="module-type-S_time"><a href=
"#module-type-S_time" class="anchor"></a><code><span class=
"keyword">module</span> <span class="keyword">type</span> <a href=
"module-type-S_time/index.html">S_time</a> = <a href=
"../../Core/Interval_intf/index.html#module-type-S_time">Core.Interval_intf.S_time</a>
<span class="keyword">with</span> <span class="keyword">type</span>
<span>'a <a href=
"module-type-S_time/index.html#type-poly_t">poly_t</a></span> :=
<span><span class="type-var">'a</span> <a href=
"index.html#type-t">t</a></span> <span class="keyword">with</span>
<span class="keyword">type</span> <span>'a <a href=
"module-type-S_time/index.html#type-poly_set">poly_set</a></span>
:= <span><span class="type-var">'a</span> <a href=
"Set/index.html#type-t">Set.t</a></span></code></dt>
<dd>
<p><code>S_time</code> is a signature that's used below to define
the interfaces for <code>Time</code> and <code>Time_ns</code>
without duplication.</p>
</dd>
</dl>
</section>
<section>
<header>
<h4 id="specialized-interval-types"><a href=
"#specialized-interval-types" class="anchor"></a>Specialized
interval types</h4>
</header>
<div class="spec module" id="module-Ofday"><a href="#module-Ofday"
class="anchor"></a><code><span class="keyword">module</span>
<a href="Ofday/index.html">Ofday</a> : <a href=
"index.html#module-type-S">S</a> <span class="keyword">with</span>
<span class="keyword">type</span> <a href=
"module-type-S/index.html#type-bound">bound</a> = <a href=
"../../../core_kernel/Core_kernel__Time_intf/module-type-Basic/Time/Ofday/index.html#type-t">
Core__.Import.Time.Ofday.t</a></code></div>
<div class="spec module" id="module-Ofday_ns"><a href=
"#module-Ofday_ns" class="anchor"></a><code><span class=
"keyword">module</span> <a href="Ofday_ns/index.html">Ofday_ns</a>
: <a href="index.html#module-type-S">S</a> <span class=
"keyword">with</span> <span class="keyword">type</span> <a href=
"module-type-S/index.html#type-bound">bound</a> = <a href=
"../../Core__Core_time_ns/Ofday/index.html#type-t">Core.Interval_intf.Time_ns.Ofday.t</a></code></div>
<div class="spec module" id="module-Time"><a href="#module-Time"
class="anchor"></a><code><span class="keyword">module</span>
<a href="Time/index.html">Time</a> : <a href=
"index.html#module-type-S_time">S_time</a> <span class=
"keyword">with</span> <span class="keyword">module</span> <a href=
"module-type-S_time/Time/index.html">Time</a> := <a href=
"../Import/index.html#module-Time">Core__.Import.Time</a>
<span class="keyword">and</span> <span class="keyword">type</span>
<a href="module-type-S_time/index.html#type-t">t</a> =
<span><a href=
"../../../core_kernel/Core_kernel__/Time_float/index.html#type-t">Core__.Import.Time.t</a>
<a href="index.html#type-t">t</a></span></code></div>
<div class="spec module" id="module-Time_ns"><a href=
"#module-Time_ns" class="anchor"></a><code><span class=
"keyword">module</span> <a href="Time_ns/index.html">Time_ns</a> :
<a href="index.html#module-type-S_time">S_time</a> <span class=
"keyword">with</span> <span class="keyword">module</span> <a href=
"module-type-S_time/Time/index.html">Time</a> := <a href=
"../../Core/Interval_intf/index.html#module-Time_ns">Core.Interval_intf.Time_ns</a>
<span class="keyword">and</span> <span class="keyword">type</span>
<a href="module-type-S_time/index.html#type-t">t</a> =
<span><a href=
"../Core_time_ns/index.html#type-t">Core.Interval_intf.Time_ns.t</a>
<a href="index.html#type-t">t</a></span></code></div>
<div class="spec module" id="module-Float"><a href="#module-Float"
class="anchor"></a><code><span class="keyword">module</span>
<a href="Float/index.html">Float</a> : <a href=
"index.html#module-type-S">S</a> <span class="keyword">with</span>
<span class="keyword">type</span> <a href=
"module-type-S/index.html#type-bound">bound</a> = <a href=
"../../../core_kernel/Core_kernel/Float/index.html#type-t">Core__.Import.Float.t</a></code></div>
<div class="spec module" id="module-Int"><a href="#module-Int"
class="anchor"></a><code><span class="keyword">module</span>
<a href="Int/index.html">Int</a> : <span class="keyword">sig</span>
... <span class="keyword">end</span></code></div>
<dl>
<dt class="spec module" id="module-Make"><a href="#module-Make"
class="anchor"></a><code><span class="keyword">module</span>
<a href="Make/index.html">Make</a> : <span class=
"keyword">functor</span> (<a href=
"Make/argument-1-Bound/index.html">Bound</a> : <span class=
"keyword">sig</span> ... <span class="keyword">end</span>)
<span>-&gt;</span> <a href="index.html#module-type-S">S</a>
<span class="keyword">with</span> <span class="keyword">type</span>
<a href="Make/index.html#type-bound">bound</a> = <a href=
"Make/argument-1-Bound/index.html#type-t">Bound.t</a></code></dt>
<dd>
<p><code>Interval.Make</code> is a functor that takes a type that
you'd like to create intervals for and returns a module with
functions over intervals of that type.</p>
</dd>
</dl>
<dl>
<dt class="spec module" id="module-Stable"><a href="#module-Stable"
class="anchor"></a><code><span class="keyword">module</span>
<a href="Stable/index.html">Stable</a> : <span class=
"keyword">sig</span> ... <span class=
"keyword">end</span></code></dt>
<dd>
<p><code>Stable</code> is used to build stable protocols. It
ensures backwards compatibility by checking the sexp and bin-io
representations of a given module. Here it's also applied to the
<code>Float</code>, <code>Int</code>, <code>Time</code>,
<code>Time_ns</code>, and <code>Ofday</code> intervals.</p>
</dd>
</dl>
</section>
</section>
</div>
</body>
</html>
